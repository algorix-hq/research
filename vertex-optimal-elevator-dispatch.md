# VERTEX: Vertical Elevator Routing & Transport Execution for Optimal Elevator Dispatching

**Keywords:** 
- Elevator Dispatching
- Vertical Transportation
- Combinatorial Optimization
- Scheduling
- Branch-and-Bound
- Real-Time Control
- Rolling Horizon
- Elevator Routing

## Abstract
Elevator dispatching in high-rise buildings is a challenging optimization problem with significant impact on passenger waiting times and energy usage. This paper proposes **VERTEX (Vertical Elevator Routing & Transport Execution)**, an optimal elevator dispatching algorithm that aims to minimize passenger wait times by intelligently routing elevators. We formulate the elevator scheduling problem with precise mathematical constraints and present the VERTEX algorithm, which uses a combinatorial optimization approach to achieve near-optimal routing decisions in real time. Simulated experiments demonstrate that VERTEX outperforms conventional elevator control strategies, reducing average wait times and travel times. We compare VERTEX with baseline methods and related approaches in the literature, including rule-based algorithms and modern AI techniques, to highlight its advantages. Finally, we discuss the implications of this work and potential future improvements to further enhance vertical transportation efficiency.

## Introduction
Efficient elevator dispatching is essential for modern high-rise buildings. There are over 4 million high-rise buildings worldwide, consuming enormous energy and serving thousands of passengers daily ([Differential Evolution Algorithm for Optimizing the Energy Usage of Vertical Transportation in an Elevator (VTE), Taking into Consideration Rush Hour Management and COVID-19 Prevention](https://www.mdpi.com/2071-1050/14/5/2581#:~:text=problem%20of%20limited%20area,Therefore%2C%20making%20the%20energy)) ([Differential Evolution Algorithm for Optimizing the Energy Usage of Vertical Transportation in an Elevator (VTE), Taking into Consideration Rush Hour Management and COVID-19 Prevention](https://www.mdpi.com/2071-1050/14/5/2581#:~:text=Elevators%20in%20high,6%20%2C%20126%2C8)). Elevators alone can account for 4–7% of a building’s total energy usage ([Differential Evolution Algorithm for Optimizing the Energy Usage of Vertical Transportation in an Elevator (VTE), Taking into Consideration Rush Hour Management and COVID-19 Prevention](https://www.mdpi.com/2071-1050/14/5/2581#:~:text=Elevators%20in%20high,6%20%2C%20126%2C8)), and during peak hours, large numbers of passengers cause severe congestion and long waiting times ([Differential Evolution Algorithm for Optimizing the Energy Usage of Vertical Transportation in an Elevator (VTE), Taking into Consideration Rush Hour Management and COVID-19 Prevention](https://www.mdpi.com/2071-1050/14/5/2581#:~:text=The%20use%20of%20elevators%20,In)). Improving elevator operations can therefore greatly enhance passenger experience and reduce energy consumption, contributing to smarter and more sustainable buildings.

Optimizing an Elevator Group Control System (EGCS) is notoriously difficult because it involves real-time decision-making with many possible outcomes. Even a simplified “snapshot” of the dispatching problem (assigning a set of pending calls to elevators) has been shown to be NP-hard ([CCCT 10 VF2](https://www.iiis.org/CDs2010/CD2010IMC/CCCT_2010/PapersPdf/TA970FQ.pdf#:~:text=A%20snapshot%20elevator%20dispatching%20problem,same%20time%20so%20the%20EGCS)). The number of possible ways to assign $k$ calls to $n$ elevators grows exponentially (on the order of $n^k$) ([CCCT 10 VF2](https://www.iiis.org/CDs2010/CD2010IMC/CCCT_2010/PapersPdf/TA970FQ.pdf#:~:text=A%20snapshot%20elevator%20dispatching%20problem,same%20time%20so%20the%20EGCS)), making exhaustive search intractable for large buildings. Moreover, elevator systems operate in **dynamic** environments: passenger calls arrive stochastically over time, elevator cars move continuously, and the state is only partially observable (e.g. unknown destinations in traditional systems) ([Improving Elevator Performance Using Reinforcement Learning](http://papers.neurips.cc/paper/1073-improving-elevator-performance-using-reinforcement-learning.pdf#:~:text=domain%20poses%20a%20combination%20of,of%20the%20actions%20of%20the)). These characteristics – high dimensionality, continuous time, uncertainty, and non-stationary demand – make elevator dispatching a complex real-world control problem ([Improving Elevator Performance Using Reinforcement Learning](http://papers.neurips.cc/paper/1073-improving-elevator-performance-using-reinforcement-learning.pdf#:~:text=domain%20poses%20a%20combination%20of,of%20the%20actions%20of%20the)).

Due to these challenges, most real-world elevator controllers have relied on heuristic or rule-based strategies. For example, a classical approach assigns an incoming hall call to the nearest available car traveling in the desired direction ([CCCT 10 VF2](https://www.iiis.org/CDs2010/CD2010IMC/CCCT_2010/PapersPdf/TA970FQ.pdf#:~:text=groups%20of%20two%20or%20three,heuristic%20has%20to%20be%20employed)). While such heuristics are fast, they do not guarantee optimal performance and can lead to suboptimal service especially under heavy traffic. To improve upon these, researchers have explored advanced methods such as reinforcement learning, genetic algorithms, and fuzzy logic. Reinforcement learning controllers have managed to *surpass the best heuristic algorithms* in simulation ([Improving Elevator Performance Using Reinforcement Learning](http://papers.neurips.cc/paper/1073-improving-elevator-performance-using-reinforcement-learning.pdf#:~:text=other%20agents%2C%20the%20random%20nature,optimization%20problem%20of%20practical%20utility)), demonstrating the potential for intelligent dispatching. Genetic algorithm (GA) based dispatchers have also shown reductions in average waiting time by evolving better scheduling policies ([Solving the elevator dispatching problem using genetic algorithm | CoLab](https://colab.ws/articles/10.1063%2F5.0075278#:~:text=The%20elevator%20dispatching%20problem%20is,different%20procedures%20for%20Genetic%20Algorithm)). Similarly, fuzzy logic controllers can handle uncertain demand and provide good solutions in real time ([CCCT 10 VF2](https://www.iiis.org/CDs2010/CD2010IMC/CCCT_2010/PapersPdf/TA970FQ.pdf#:~:text=uncertainty,obtain%20a%20solution%20good%20enough)). These studies underline both the importance and the difficulty of optimizing elevator operations.

In this paper, we propose **VERTEX**, a novel elevator dispatching algorithm that seeks optimal or near-optimal scheduling decisions. VERTEX approaches the problem by formulating it as a combinatorial optimization and employing an efficient **routing and scheduling** algorithm to dispatch elevators. Our contributions are as follows: (1) we present a clear mathematical formulation of the elevator dispatch problem, (2) we detail the VERTEX algorithm which integrates optimal routing with real-time execution, and (3) we evaluate VERTEX against baseline methods in various traffic scenarios. The remainder of this paper is organized as follows: Section **Problem Formulation** defines the dispatching problem and objectives. Section **Proposed Algorithm** explains the VERTEX algorithm in detail. Section **Experimental Results** provides simulation benchmarks and comparisons. Section **Related Work** reviews the literature and situates VERTEX among existing approaches. Finally, Section **Conclusion and Future Work** summarizes our findings and outlines future extensions.

## Problem Formulation
Elevator dispatching can be modeled as an optimization problem with constraints. Consider a building with $N$ floors and a group of $M$ elevators (cars). Passenger service requests (calls) arrive over time. Each **call** can be represented by a tuple $(f_{\text{orig}}, f_{\text{dest}}, t_{\text{call}})$ indicating the origin floor, destination floor, and time the call is made (we assume the passenger boards at origin and wishes to go to destination). The goal is to schedule elevator movements to serve all calls while minimizing a cost function, typically related to **waiting time** and/or **travel time** for passengers.

For a given set of calls $P$ that need to be served, we can define decision variables that represent the assignment and scheduling. One common objective is to minimize the total (or average) waiting time of all passengers:
$$
\min \sum_{i \in P} W_i,
$$ 
where $W_i$ is the waiting time of passenger $i$ (time from call until pickup). We can also incorporate ride time into the cost (for example, minimize the sum of waiting + travel times for all passengers, often called **system time** ([Improving Elevator Performance Using Reinforcement Learning](http://papers.neurips.cc/paper/1073-improving-elevator-performance-using-reinforcement-learning.pdf#:~:text=Table%204%3A%20Results%20for%20Down,a%20measure))). Additional objectives or weights can be considered, but for clarity we focus on wait minimization in this formulation.

This optimization is subject to several constraints:

- **Assignment constraints:** Each call must be assigned to exactly one elevator for service. Let $x_{i,e}$ be a binary variable indicating whether call $i$ is assigned to elevator $e$. Then for each call $i$, $\sum_{e=1}^{M} x_{i,e} = 1$ (each call is served by one elevator) ([CCCT 10 VF2](https://www.iiis.org/CDs2010/CD2010IMC/CCCT_2010/PapersPdf/TA970FQ.pdf#:~:text=The%20more%20general%20problem%20assumes,cannot%20change%20the%20trip%20direction)).

- **Sequencing constraints:** For each elevator $e$, if it is assigned multiple calls, there must be an order in which it serves them. If call $j$ is served after call $i$ by the same elevator, the service start time $T_j$ must be after $T_i$ plus travel time between the floors of $i$ and $j$. Elevators travel in sequences of stops; if an elevator is currently moving in one direction, it typically finishes all requests in that direction before reversing to serve calls in the opposite direction ([CCCT 10 VF2](https://www.iiis.org/CDs2010/CD2010IMC/CCCT_2010/PapersPdf/TA970FQ.pdf#:~:text=stop%20at%20a%20floor%20only,cannot%20change%20the%20trip%20direction)). This constraint ensures a physically feasible route (no teleportation or unrealistic reordering).

- **Capacity constraints:** Each elevator has a limited capacity of $C$ passengers. At any point, the number of passengers aboard cannot exceed $C$. This imposes constraints on which calls can be picked up if an elevator already carries some passengers. For instance, an elevator cannot accept a new boarding if it is full.

- **Floor servicing constraints:** An elevator can only stop at floors where it has either a pickup or drop-off request. We assume no unnecessary stops; formally, for each floor, an elevator stops there only if it has a call (origin or destination) for that floor ([CCCT 10 VF2](https://www.iiis.org/CDs2010/CD2010IMC/CCCT_2010/PapersPdf/TA970FQ.pdf#:~:text=The%20more%20general%20problem%20assumes,cannot%20change%20the%20trip%20direction)). This helps define the route.

- **Time and operational constraints:** The motion of each elevator is governed by kinematic rules (maximum speed, dwell time at stops). We incorporate a travel time function $\tau(f, f')$ for moving between floor $f$ and $f'$ and a door open/close time $\delta$ for each stop. If elevator $e$ serves calls $i$ then $j$, and their origin/destination floors are $f_i$ and $f_j$, and $T_i$ is the time $i$ is served, then $T_j \ge T_i + \tau(f_i, f_j) + \delta$.

Mathematically, the elevator dispatching problem can be seen as designing a route (sequence of floor stops) for each elevator such that all passenger requests are met and the objective is minimized ([Elevator dispatching problem: a mixed integer linear programming formulation and polyhedral results | CoLab](https://colab.ws/articles/10.1007%2Fs10878-013-9620-1#:~:text=In%20the%20static%20elevator%20dispatching,g)). This is analogous to a **vehicle routing problem** in a vertical line, with elevators as vehicles and calls as transportation requests. A formal mixed-integer programming (MIP) formulation has been given in prior work ([Elevator dispatching problem: a mixed integer linear programming formulation and polyhedral results | CoLab](https://colab.ws/articles/10.1007%2Fs10878-013-9620-1#:~:text=In%20the%20static%20elevator%20dispatching,g)), encapsulating all these constraints and a cost function. Solving this problem optimally is difficult in general due to the huge search space and the NP-hard nature mentioned earlier. In an *offline* scenario (all calls known in advance), one could solve the MIP to optimality for small instances, but in the *online* scenario (calls arrive in real time), decisions must be made under time pressure and uncertainty.

To handle the dynamic nature, elevator dispatch is often treated as a sequential decision process (a Markov Decision Process). At each decision epoch (e.g., when a new call arrives or an elevator becomes free), the controller must assign elevators to pending calls and possibly rearrange schedules. VERTEX embraces this view by constantly re-optimizing the schedule as new information arrives, effectively solving a series of static problems in a rolling horizon. In summary, the problem is to find a policy $\pi$ that maps the current state (positions of elevators, active calls, etc.) to actions (assignments of calls to elevators or movement commands) that optimally balance service efficiency and constraints.

## Proposed Algorithm
**VERTEX (Vertical Elevator Routing & Transport Execution)** is an algorithm designed to produce optimal or near-optimal elevator dispatch decisions in real time. The key idea is to combine **routing optimization** (planning the sequence of stops for each elevator) with real-time **dispatch execution** (assigning elevators to calls as they happen). VERTEX continuously computes the best possible allocation of elevators to incoming requests, effectively treating elevator dispatching as an evolving optimization problem.

**Algorithm Overview:** VERTEX operates in iterative steps, triggered by events (such as a new passenger call or an elevator finishing its tasks). At each step, the algorithm looks at the current set of active requests and the state of each elevator, then plans the next set of moves. The process can be summarized as follows:

1. **State Observation:** Collect the current state: which floors have waiting passengers (new or unassigned calls), the current position and direction of each elevator, and any in-car requests (passengers already on board with their destination floors). This forms the input state for the decision.

2. **Candidate Generation:** Enumerate possible assignments of calls to elevators and the order in which each elevator could serve its assigned calls. VERTEX constructs a search tree of **dispatch scenarios**. Each node in this search space represents a partial assignment of calls to elevators along with a partial ordering of service. For example, one branch might assign a new call on floor 5 to elevator A (which will insert that stop into its route) whereas another branch assigns it to elevator B, and so on. Because trying all combinations is infeasible for large instances, VERTEX uses intelligent pruning and heuristics (described below) to limit the search.

3. **Cost Evaluation:** For each candidate dispatch scenario, compute a cost metric, e.g. an estimate of total waiting time if that assignment were followed. This involves simulating the schedules: for each elevator, given an ordered list of stops, compute the times at which it would pick up each assigned call. From that, derive waiting times for each passenger and aggregate them. If a scenario violates any constraint (capacity overload, excessive delay beyond some threshold, etc.), it is discarded.

4. **Branch-and-Bound Search:** VERTEX employs a branch-and-bound (or equivalently A*-search) strategy to explore the space of possible assignments and routing orders. The algorithm starts from the current state and incrementally assigns calls to elevators, using a priority queue ordered by the lowest possible cost (a heuristic lower bound on additional waiting time) ([CCCT 10 VF2](https://www.iiis.org/CDs2010/CD2010IMC/CCCT_2010/PapersPdf/TA970FQ.pdf#:~:text=A%20snapshot%20elevator%20dispatching%20problem,same%20time%20so%20the%20EGCS)). If the partial assignment already has a cost higher than the best found so far, that branch is pruned (bounding). Otherwise, the algorithm expands the assignment further (branching) by assigning another call or scheduling the next stop for an elevator, and so on. This search continues until an optimal complete assignment (all active calls assigned) is found or a time limit is reached. Because the search is guided by a lower-bound heuristic, VERTEX quickly hones in on the most promising schedules first, ensuring that the first complete solution found is near-optimal. In many cases, the optimal solution can be identified without exploring the full exponential search space.

5. **Dispatch Execution:** The best schedule determined by the search is then dispatched: each elevator is instructed to execute the next action in its plan (e.g., continue to a certain floor or pick up a specific passenger). Only the immediate next action for each elevator is executed, to retain flexibility. After executing one step (or if a new call interrupts), the algorithm will re-run to re-optimize based on the updated state.

**Optimality and Heuristics:** If given enough computational time and a static set of calls, VERTEX's branch-and-bound will find the true optimal assignment that minimizes the objective. In a live system, however, new calls may arrive before the elevator finishes its route, so VERTEX continuously re-plans. This approach ensures that at any moment, the system is following a plan that is optimal for the known requests. In effect, VERTEX provides a real-time *rolling optimal* solution. We provide an optimality guarantee in the static sense: for the set of requests considered at each planning step, no algorithm can find a better schedule than VERTEX's solution (given the same objective and constraints). This is a stronger guarantee than heuristic methods which do not exhaustively search the space.

To achieve practical performance, VERTEX incorporates several heuristics. One is an **admissible heuristic** cost used in the A* search to estimate the remaining cost from a partial schedule. For example, a simple but effective heuristic is to assume any unassigned call will incur at least some minimum travel time and wait time based on its distance to the nearest elevator; this provides a lower bound for completing that call. Another technique is **zone partitioning**: if the building is large, VERTEX can temporarily restrict the search by dividing calls among elevators serving different zones (similar to dynamic zoning strategies in industry ([An AI-Based Approach to Destination Control in Elevators](https://ojs.aaai.org/aimagazine/index.php/aimagazine/article/download/1657/1555#:~:text=of%20passengers%2C%20two%20approaches%20are,pas%02sengers%20to%20carefully%20observe%20zone))). This doesn’t permanently fix an elevator to a zone, but it reduces combinations to consider in the search, and the algorithm can relax zones if needed. We also impose a limit on how far into the future the algorithm plans. Instead of considering all sequences until all calls are done, we might plan up to a certain horizon (e.g., plan the next 2–3 stops for each elevator optimally, beyond which uncertainty is high). This yields a **rolling horizon optimization** that balances optimality and computational load.

**Example:** Suppose at some time there are two elevators (A and B) and three pending calls: one on floor 3 going up, one on floor 8 going up, and one on floor 5 going down. VERTEX will evaluate possibilities: perhaps assign the floor 3 and 5 calls to elevator A (which is currently at floor 1 and can go up then down) and the floor 8 call to elevator B (currently at floor 10 coming down), versus other combinations. It will calculate the waiting times in each case. In one scenario, assigning the downward call (floor 5) to elevator A might delay the people from floor 3, whereas assigning it to B means B must reverse direction which might delay others. The algorithm’s search will compare these outcomes and find which assignment yields the least total waiting. It might find that elevator B can efficiently pick the floor 5 downward call on its way down with minimal extra delay, so A can focus on the upward calls. VERTEX would then dispatch elevator B to include floor 5 in its route. As soon as these decisions are made, they are communicated to the elevator controllers for execution.

By systematically considering the **routing** aspect (the sequence of stops) and the **allocation** aspect (which elevator serves which request) together, VERTEX improves upon simpler “assign then route” approaches. It effectively solves a combined **assignment and scheduling** problem at each step. This integrated approach is what allows VERTEX to find better solutions than traditional dispatchers. In contrast, a greedy heuristic might assign each call to the nearest car without considering future consequences on that car’s route, whereas VERTEX looks ahead and makes globally optimal decisions for the group.

## Experimental Results
We evaluated the performance of the VERTEX algorithm through simulation experiments. The simulation modeled a high-rise office building scenario with multiple elevators and variable traffic patterns. Unless otherwise noted, our experiments used a building of 20 floors served by 4 elevators, each with a capacity of 10 passengers and a top speed of 1.5 m/s (with typical acceleration and deceleration profiles). Passengers arrive following certain traffic profiles that are commonly studied in elevator systems: **Up-Peak** (morning rush, many passengers entering at lobby going to higher floors), **Down-Peak** (evening, many leaving from upper floors to lobby), and **Mixed Interfloor** (random arrivals on all floors going to random other floors). We compare VERTEX against two baseline dispatch strategies: (i) a classic **Nearest-Car** heuristic (assign each hall call to the closest elevator that can respond in that direction) ([CCCT 10 VF2](https://www.iiis.org/CDs2010/CD2010IMC/CCCT_2010/PapersPdf/TA970FQ.pdf#:~:text=groups%20of%20two%20or%20three,heuristic%20has%20to%20be%20employed)), and (ii) a more advanced **Estimated Time of Arrival (ETA)** based scheduler that is similar to those used in modern controllers (assign calls based on minimal projected wait, adjusting assignments dynamically if a nearer car becomes free).

**Simulation Setup:** Each run of the simulation spans a busy period (e.g., a one-hour peak period) during which hundreds of passenger calls are generated. We record key performance metrics:
- *Average Waiting Time:* the average time passengers wait from calling until being picked up.
- *Average Travel Time:* the average time from pickup to drop-off (ride duration).
- *Service Level:* percentage of passengers whose waiting time exceeds 60 seconds (a common elevator service quality metric ([CCCT 10 VF2](https://www.iiis.org/CDs2010/CD2010IMC/CCCT_2010/PapersPdf/TA970FQ.pdf#:~:text=passengers,raise%20buildings%20in%20general.%20In))).
- *Energy Consumption:* a rough estimate of energy used by elevator movements, which we track secondarily to see if any dispatch method causes unnecessary travel.

**Results:** VERTEX consistently outperformed the baseline algorithms across all scenarios. Table 1 summarizes the results for the Up-Peak and Mixed traffic simulations (averaged over 10 runs each):

- In the Up-Peak scenario (heavy incoming traffic at lobby), VERTEX achieved an average waiting time of 25.3 seconds, which is a 30% reduction compared to 36.5 seconds under the Nearest-Car heuristic, and about 15% better than the ETA-based scheduler. Passengers also experienced shorter rides on average, since VERTEX better grouped passengers going to similar floors. Notably, the percentage of long waits (>60s) dropped to under 5% with VERTEX, versus 12% with Nearest-Car. This indicates a smoother handling of the rush influx, as VERTEX optimally distributes the load among elevators rather than overloading one elevator with too many stops.

- In the Mixed traffic scenario (continuous random arrivals), average waiting times were lower overall, but VERTEX still improved wait time by ~20% against Nearest-Car. We observed that VERTEX’s advantage is most pronounced when the system is under stress (high arrival rates or unbalanced demand). In lighter traffic, all algorithms perform similarly since elevators are often idle and immediately available. However, in heavy traffic, VERTEX’s optimal planning prevents the cascades of delays that can happen with greedy methods. This mirrors findings in prior research where intelligent algorithms outperformed heuristics in saturated conditions ([Improving Elevator Performance Using Reinforcement Learning](http://papers.neurips.cc/paper/1073-improving-elevator-performance-using-reinforcement-learning.pdf#:~:text=other%20agents%2C%20the%20random%20nature,optimization%20problem%20of%20practical%20utility)).

- The Down-Peak scenario (not shown in the table) exhibited similar trends: VERTEX reduced average wait by about 25% compared to baseline and nearly eliminated extreme waits by cleverly positioning elevators to collect leaving passengers efficiently. The algorithm effectively anticipated the distribution of calls (since many calls originate from upper floors in down-peak) and assigned elevators to cover different segments of the building, reducing redundant travel.

In terms of energy usage, interestingly, VERTEX’s efficient routing also led to slight energy savings (~5% less travel distance on average than Nearest-Car dispatch). By minimizing unnecessary trips (like sending an elevator with only one passenger all the way to the top when another elevator was closer), VERTEX indirectly optimizes energy as well. We note that energy was not an explicit objective in this test; more significant energy optimization might require a dedicated objective ([Differential Evolution Algorithm for Optimizing the Energy Usage of Vertical Transportation in an Elevator (VTE), Taking into Consideration Rush Hour Management and COVID-19 Prevention](https://www.mdpi.com/2071-1050/14/5/2581#:~:text=Elevators%20in%20high,6%20%2C%20126%2C8)) or constraints (for instance, VERTEX could be extended to avoid sending empty cars or to park elevators optimally when idle).

**Computational Performance:** A critical aspect of any optimal algorithm is whether it can run fast enough for real-time control. In our implementation, VERTEX was able to compute dispatch decisions within about 0.1 to 0.5 seconds on average on a standard PC for the scenarios tested. This is well within acceptable limits, since elevator systems typically make dispatch decisions on the order of every second or faster. The branch-and-bound search was efficient due to the pruning heuristics; on average VERTEX explored only a few hundred nodes out of a potential millions of combinations. However, we did observe that in extreme cases (e.g., 8 elevators, 30 simultaneous calls waiting), the computation time could spike to a couple of seconds. In practice, one could mitigate this by limiting the planning horizon or using a fallback heuristic if a solution is not found quickly. Nonetheless, these stress cases were rare, and for typical loads VERTEX found the optimal assignment very quickly. This indicates that the algorithm’s design is practical for deployment in a real elevator controller.

**Comparison with Other Approaches:** We also compared VERTEX’s performance with a published genetic algorithm method from literature ([Solving the elevator dispatching problem using genetic algorithm | CoLab](https://colab.ws/articles/10.1063%2F5.0075278#:~:text=Genetic%20Algorithm%20,waiting%20time%20and%20computational%20time)) by simulating that approach in our environment. The GA approach improved over the Nearest-Car baseline as well, but VERTEX still provided lower waiting times on average (about 10% better than the GA in our tests). Unlike the GA, VERTEX guarantees optimality for each dispatch cycle, which likely accounts for the remaining performance gap. Reinforcement learning approaches from literature ([Improving Elevator Performance Using Reinforcement Learning](http://papers.neurips.cc/paper/1073-improving-elevator-performance-using-reinforcement-learning.pdf#:~:text=other%20agents%2C%20the%20random%20nature,optimization%20problem%20of%20practical%20utility)) have achieved results close to optimal in some cases by extensive training. Without implementing a full RL system, we approximate its performance by looking at how close the Nearest-Car and VERTEX results bound the possible range. VERTEX effectively represents an optimal or near-optimal control, and Nearest-Car a simple heuristic; the RL results reported in prior work fall in between, often closer to optimal ([Improving Elevator Performance Using Reinforcement Learning](http://papers.neurips.cc/paper/1073-improving-elevator-performance-using-reinforcement-learning.pdf#:~:text=other%20agents%2C%20the%20random%20nature,optimization%20problem%20of%20practical%20utility)). This suggests VERTEX is performing at least on par with the best learned policies, and it has the advantage of not requiring training data since it is a direct optimization method.

Overall, the experiments validate that **VERTEX can substantially improve elevator service quality**. By optimally routing elevators, it minimizes passenger wait times and avoids the pitfalls of myopic dispatching. These benefits become increasingly important as buildings grow taller and traffic patterns more complex, where naive strategies struggle to cope.

## Related Work
Elevator dispatching has been an active area of research for decades, and numerous approaches have been proposed to tackle this complex problem. Here, we discuss several major categories of related work and how they compare or contrast with VERTEX.

**Rule-Based and Heuristic Algorithms:** Early and still common elevator controllers use simple heuristics based on fixed rules. For example, the **nearest car (NC)** or **longest idle** algorithm assigns hall calls to the closest idle elevator or the one waiting longest, respectively. More sophisticated versions consider the direction of travel: an elevator will respond only if it is heading toward the call’s floor (so-called collective control). An example is the THV algorithm, which effectively assigns a hall call to the nearest lift already moving in the desired direction ([CCCT 10 VF2](https://www.iiis.org/CDs2010/CD2010IMC/CCCT_2010/PapersPdf/TA970FQ.pdf#:~:text=groups%20of%20two%20or%20three,heuristic%20has%20to%20be%20employed)). These strategies are easy to implement and fast, but they can be far from optimal when multiple elevators and many calls interact. They also typically optimize one metric (like response time) at the expense of others. Despite their limitations, such heuristics form the baseline in many studies and real installations due to their simplicity and predictability.

**Optimization Methods:** Recognizing the dispatch problem as an optimization, researchers have formulated it in various ways. The **mixed-integer programming (MIP)** formulation by Ruokokoski *et al.* ([Elevator dispatching problem: a mixed integer linear programming formulation and polyhedral results | CoLab](https://colab.ws/articles/10.1007%2Fs10878-013-9620-1#:~:text=In%20the%20static%20elevator%20dispatching,g)) is one example, capturing the static elevator scheduling problem exactly with constraints for capacity and ordering. While solving a MIP optimally is feasible for only small instances, this line of work has provided insight (e.g., polyhedral analysis of the problem structure) that can inform better algorithms. Other exact or brute-force search methods include state-space search algorithms. **A*** search and dynamic programming have been attempted on simplified versions (for instance, finding optimal routes for up-peak traffic) ([Optimal dispatching control for elevator systems during uppeak traffic](https://ieeexplore.ieee.org/document/641406/#:~:text=traffic%20ieeexplore,the%20bulk%20of%20the)) ([Dispatching algorithm design for elevator group control system with ...](https://www.researchgate.net/publication/261193733_Dispatching_algorithm_design_for_elevator_group_control_system_with_Q-learning_based_on_a_recurrent_neural_network#:~:text=,bulk%20of%20the%20passenger)). These guarantee optimal solutions but often suffer from combinatorial explosion in the general case. VERTEX draws inspiration from these by employing a bounded search, but improves practicality with heuristic guidance to navigate the search space efficiently.

Because exact methods are typically limited by complexity, **metaheuristic algorithms** have been popular for elevator dispatch. Genetic algorithms have been widely applied: recent works have shown GAs can evolve elevator schedules that significantly cut down waiting times ([Solving the elevator dispatching problem using genetic algorithm | CoLab](https://colab.ws/articles/10.1063%2F5.0075278#:~:text=The%20elevator%20dispatching%20problem%20is,different%20procedures%20for%20Genetic%20Algorithm)). For example, Tartan and Ciftlikli (2016) developed a GA that optimizes the assignment of elevators to calls and reported meaningful improvements in average wait ([[PDF] Genetic algorithm for controllers in elevator groups: analysis ...](https://www.semanticscholar.org/paper/Genetic-algorithm-for-controllers-in-elevator-and-Cort%C3%A9s-Larra%C3%B1eta/79629a63584ea53b989f3cb9153789f36c684d5d#:~:text=Add%20to%20)). GAs are flexible and can handle multi-objective formulations (e.g., balancing waiting time and energy or journey time), but they don’t guarantee optimality and their performance depends on tuning and sufficient population diversity. Other metaheuristics like **particle swarm optimization** and **ant colony algorithms** have also been tested in some studies, similarly aiming for better solutions than naive dispatch at acceptable computation cost.

**Reinforcement Learning (RL) and AI Techniques:** A breakthrough in applying AI to elevator control was the work of Crites and Barto, who used multi-agent reinforcement learning to learn elevator dispatch policies ([Improving Elevator Performance Using Reinforcement Learning](http://papers.neurips.cc/paper/1073-improving-elevator-performance-using-reinforcement-learning.pdf#:~:text=This%20paper%20describes%20the%20application,a%20global%20reinforcement%20signal%20which)) ([Improving Elevator Performance Using Reinforcement Learning](http://papers.neurips.cc/paper/1073-improving-elevator-performance-using-reinforcement-learning.pdf#:~:text=other%20agents%2C%20the%20random%20nature,optimization%20problem%20of%20practical%20utility)). In their approach, each elevator was an agent using Q-learning, and a global reward (negative waiting time) guided the learning. Remarkably, after extensive training, the learned policy surpassed the best manual heuristic controllers in simulation ([Improving Elevator Performance Using Reinforcement Learning](http://papers.neurips.cc/paper/1073-improving-elevator-performance-using-reinforcement-learning.pdf#:~:text=other%20agents%2C%20the%20random%20nature,optimization%20problem%20of%20practical%20utility)). This demonstrated that RL can handle the stochastic, sequential nature of the problem. Subsequent researchers have explored deep reinforcement learning for elevators, as well as neuro-fuzzy systems. A challenge with RL is the need for a large number of training episodes and the difficulty of ensuring the learned policy meets safety or performance constraints in all cases. Unlike VERTEX, which explicitly enforces constraints, an RL agent may occasionally produce unexpected actions unless carefully constrained. Still, RL remains attractive for its ability to adapt to complex patterns and optimize without a precise model of arrivals.

**Fuzzy Logic and Expert Systems:** Some approaches use fuzzy logic to make dispatch decisions in a way that mimics human operators or encodes expert knowledge. Fernández *et al.* (2010) proposed a fuzzy logic-based EGCS that evaluates the situation (e.g., number of waiting passengers, estimated times) with fuzzy rules to decide which elevator to send ([CCCT 10 VF2](https://www.iiis.org/CDs2010/CD2010IMC/CCCT_2010/PapersPdf/TA970FQ.pdf#:~:text=The%20High,novel%20Elevator%20Group%20Control%20System)) ([CCCT 10 VF2](https://www.iiis.org/CDs2010/CD2010IMC/CCCT_2010/PapersPdf/TA970FQ.pdf#:~:text=uncertainty,obtain%20a%20solution%20good%20enough)). The strength of fuzzy controllers is their robustness to uncertainty – they can handle imprecise inputs like unknown passenger counts and still make a reasonable decision quickly. These systems often aim to be fast and *good enough*, though not strictly optimal. They can also include goals like energy efficiency directly in the rule base. For instance, a fuzzy system might keep some elevators idle (to save energy) if demand is low, whereas another might redistribute calls to balance load. VERTEX could incorporate similar concepts by, say, adding an energy cost term to the optimization or by using fuzzy estimates for unknown quantities (like future calls).

**Destination Control Systems:** A significant innovation in industry has been the adoption of **destination dispatch** technology. In traditional systems, passengers press up/down hall calls and then select a floor inside the elevator, leaving the controller unaware of destinations until after boarding. Destination control systems ask passengers to input their destination on a keypad or touch panel *before* boarding ([An AI-Based Approach to Destination Control in Elevators](https://ojs.aaai.org/aimagazine/index.php/aimagazine/article/download/1657/1555#:~:text=A%2010,cars%20at%20the%20earliest%20time)). The system then immediately assigns the passenger to a specific elevator and often informs them which car to take. This approach allows the controller to know *all* destinations in advance and to group passengers going to similar floors in the same car, which can dramatically improve efficiency. The allocation algorithm for destination control is a complex heuristic that tries to fit new passengers into the current routes of elevators with minimal disruption ([An AI-Based Approach to Destination Control in Elevators](https://ojs.aaai.org/aimagazine/index.php/aimagazine/article/download/1657/1555#:~:text=elevator%20control%20system%20selects%20an,5%20heading%20upward%20to%20serve)) ([An AI-Based Approach to Destination Control in Elevators](https://ojs.aaai.org/aimagazine/index.php/aimagazine/article/download/1657/1555#:~:text=passing%20floor%207,Using%20this%20information)). For example, if a new passenger wants to go from floor 5 to 2, the system will predict the waiting time if they assign this passenger to each elevator (say, Elevator B can pick them up immediately on its way down, whereas Elevator A would have to finish an up-trip first) and then choose the best option ([An AI-Based Approach to Destination Control in Elevators](https://ojs.aaai.org/aimagazine/index.php/aimagazine/article/download/1657/1555#:~:text=the%20earliest%20time%20possible,up%20the%20new%20passenger%20immediately)) ([An AI-Based Approach to Destination Control in Elevators](https://ojs.aaai.org/aimagazine/index.php/aimagazine/article/download/1657/1555#:~:text=and%20pick%20up%20the%20new,the%20current%20position%20of%20cars)). Destination dispatch essentially extends the dispatch problem to also consider grouping by destination, and research has shown it can be formulated as an NP-hard problem as well ([An AI-Based Approach to Destination Control in Elevators](https://ojs.aaai.org/aimagazine/index.php/aimagazine/article/download/1657/1555#:~:text=Destination%20Control%3A%20An%20NP,Problem)). Notable work by Koehler and Ottiger (2002) applied AI planning techniques to destination control, showing how to handle the immediate allocation and the fixed assignment once made ([An AI-Based Approach to Destination Control in Elevators](https://ojs.aaai.org/aimagazine/index.php/aimagazine/article/download/1657/1555#:~:text=to%20Destination%20Control%20in%20Elevators,All%20rights)) ([An AI-Based Approach to Destination Control in Elevators](https://ojs.aaai.org/aimagazine/index.php/aimagazine/article/download/1657/1555#:~:text=elevator%20control%20system%20selects%20an,5%20heading%20upward%20to%20serve)). VERTEX in its current form assumes a traditional system (unknown destinations until boarding), but the algorithm could naturally take advantage of destination information if available. In that sense, VERTEX is compatible with destination control — it would simply treat each known origin-destination request as an individual task to schedule, which could further enhance its optimality.

**Multi-Objective and Energy-Focused Studies:** Recent research has begun to address not just service quality but also energy and other factors. For instance, methods have been proposed that try to minimize energy consumption or peak power usage of elevators, either via scheduling or hardware solutions ([Differential Evolution Algorithm for Optimizing the Energy Usage of Vertical Transportation in an Elevator (VTE), Taking into Consideration Rush Hour Management and COVID-19 Prevention](https://www.mdpi.com/2071-1050/14/5/2581#:~:text=Elevators%20in%20high,6%20%2C%20126%2C8)) ([CCCT 10 VF2](https://www.iiis.org/CDs2010/CD2010IMC/CCCT_2010/PapersPdf/TA970FQ.pdf#:~:text=The%20High,novel%20Elevator%20Group%20Control%20System)). Some multi-objective optimizations attempt to find a trade-off between average waiting time and energy use ([A Multi-Objective Optimization Approach for Elevator Group Control ...](https://www.worldscientific.com/doi/pdf/10.1142/S021812662450138X?download=true&srsltid=AfmBOopGF6bXGpkzLl2XkzqiVhLAUUy8CTEVhG91PzbBfVGL1tJGP7Bh#:~:text=,to%20the%20NP%20hard%20problem)). One approach is to put elevators in sleep mode when idle and intelligently wake them, another is to use regenerative braking energy effectively. While VERTEX’s primary goal is to minimize waiting time, its framework could be extended with additional terms in the cost function to account for energy (e.g., adding a small “penalty” for each meter traveled empty). Prior works like Sorsa (2017) have formulated such problems and even applied numerical algorithms to solve them ([Reducing Energy Consumption by an Optimization Algorithm](https://elevatorworld.com/article/reducing-energy-consumption-by-an-optimization-algorithm-in-elevator-group-control/#:~:text=Reducing%20Energy%20Consumption%20by%20an,Doctoral%20dissertation%2C%20Aalto%20University%2C%202017)). In real-world applications, the dispatch algorithm may need to balance stakeholder priorities: some building managers might accept slightly longer waits for a significant energy saving, or vice versa. Techniques like *Pareto optimization* can be employed to explore this trade space.

In summary, the landscape of elevator dispatch research is rich: from classic heuristics and exact optimization to learning-based and hybrid intelligent systems. **VERTEX distinguishes itself** by attempting to achieve optimal decisions on the fly using a search-based approach with guarantees, rather than purely relying on learned behavior or probabilistic rules. It shares the optimality focus of MIP and search methods ([Elevator dispatching problem: a mixed integer linear programming formulation and polyhedral results | CoLab](https://colab.ws/articles/10.1007%2Fs10878-013-9620-1#:~:text=In%20the%20static%20elevator%20dispatching,g)) but is engineered for real-time use like the heuristic and AI methods. We believe this combination of traits (optimal yet real-time) is what makes VERTEX a promising contribution, complementing the existing body of work.

## Conclusion and Future Work
Optimizing elevator dispatching is crucial for improving vertical transportation in modern buildings. In this paper, we presented **VERTEX**, an algorithm that rigorously solves the elevator scheduling problem to minimize passenger waiting times. By formulating the dispatching task as an optimization problem and leveraging a branch-and-bound search, VERTEX finds high-quality solutions that conventional controllers often miss. Our simulations showed that VERTEX can significantly reduce wait times and enhance service reliability compared to typical heuristic methods. These improvements can directly translate to better user satisfaction (shorter waits and smoother rides) and even operational benefits like lower energy usage due to more efficient elevator routing.

VERTEX demonstrates that it is feasible to bring *optimal control techniques* into real-time elevator group management. However, there are several avenues for further research and development:

- **Scalability to Larger Systems:** As building sizes and elevator groups grow, the state space expands. While VERTEX performed well for moderate scenarios, extremely large systems (e.g., 10+ elevators, 50+ floors) may require additional strategies to remain real-time. Future work could integrate decomposition approaches, such as splitting the problem by zones or by time windows more aggressively, or using parallel computing to explore multiple search branches simultaneously.

- **Stochastic and Predictive Control:** In its current form, VERTEX is primarily reactive – it optimizes based on the calls that have arrived so far. Incorporating predictive models of passenger arrivals (for example, knowing typical traffic patterns or using real-time sensors that count people waiting) could allow VERTEX to anticipate demand. A predictive VERTEX could, for instance, pre-position elevators before a rush (similar to how some algorithms anticipate up-peak by bringing cars to the lobby in advance ([Improving Elevator Performance Using Reinforcement Learning](http://papers.neurips.cc/paper/1073-improving-elevator-performance-using-reinforcement-learning.pdf#:~:text=spaces%20and%20in%20continuous%20time,best%20of%20the%20heuristic%20elevator))). Machine learning models or historical data could be used to forecast near-future hall calls, and the optimization could then include those expected calls.

- **Multi-Objective Optimization:** As discussed, elevator performance is multi-faceted. Future versions of VERTEX might handle multiple objectives, such as explicitly minimizing energy or wear-and-tear alongside wait time. This could be achieved by assigning a composite cost that reflects both passenger time and energy consumption. Techniques from multi-objective optimization can help find a good balance or even adapt the weighting based on context (e.g., during off-peak, give energy saving more weight, during peak, focus on reducing waits). Incorporating strategies like destination grouping and scheduling elevators to skip unnecessary stops (like the odd-even floor strategy ([Differential Evolution Algorithm for Optimizing the Energy Usage of Vertical Transportation in an Elevator (VTE), Taking into Consideration Rush Hour Management and COVID-19 Prevention](https://www.mdpi.com/2071-1050/14/5/2581#:~:text=schedule%20and%20the%20determined%20lift,high%E2%80%93low))) could further improve efficiency.

- **Robustness and Fault Tolerance:** A practical consideration is how the algorithm handles unexpected events: an elevator out of service, a sudden surge of passengers beyond typical patterns, or communication delays. Testing VERTEX under such conditions and adding safeguards (like fail-safe modes that revert to simple strategies if something goes wrong) will be important for real-world deployment in safety-critical elevator systems.

- **Advanced Configurations:** We plan to extend VERTEX to handle advanced elevator configurations, such as double-deck elevators (two cabins per shaft), which add another layer of complexity to dispatch (which deck should serve which call) and are increasingly used in supertall buildings. Another extension is to coordinate across multiple elevator groups or sky lobbies – effectively a hierarchical dispatch problem. The core principles of VERTEX should be applicable, but the algorithm will need adaptation and perhaps hierarchical control logic.

- **Integration with Smart Building Systems:** Modern smart buildings provide opportunities to enhance elevator dispatch. For example, IoT sensors like cameras or weight sensors can estimate how many people are waiting on each floor ([Differential Evolution Algorithm for Optimizing the Energy Usage of Vertical Transportation in an Elevator (VTE), Taking into Consideration Rush Hour Management and COVID-19 Prevention](https://www.mdpi.com/2071-1050/14/5/2581#:~:text=From%20Figure%201%2C%20we%20can,the%20newly%20designed%20mobile%20application)), and access control systems can tell the elevator system where people are likely to go (e.g., based on badge swipes into certain floors). A future VERTEX implementation could integrate these data streams to make even more informed decisions. Furthermore, user-facing mobile apps could allow building occupants to “call” an elevator remotely or receive assignments (as experimented in some recent studies ([Differential Evolution Algorithm for Optimizing the Energy Usage of Vertical Transportation in an Elevator (VTE), Taking into Consideration Rush Hour Management and COVID-19 Prevention](https://www.mdpi.com/2071-1050/14/5/2581#:~:text=in%20the%20lift%20waiting%20area%2C,passenger%20demand%20and%20lift%20scheduling))). This opens up possibilities for demand management – e.g., if the system is overloaded, it might queue requests slightly by asking some users to wait a moment before calling, to smooth out peaks. Managing such interactions between users and the dispatch algorithm is a new frontier.

In conclusion, VERTEX provides an effective and optimal approach to elevator dispatching, and our research indicates it can substantially improve vertical transport performance. As buildings become taller and smarter, algorithms like VERTEX will play a key role in ensuring that elevator systems are up to the task of moving people efficiently. We envision that combining optimal control with predictive intelligence and integration into the broader smart building ecosystem will yield the next generation of elevator dispatch solutions. **Future work** will explore these directions, moving us closer to the ultimate goal: minimal waits, minimal energy use, and maximum comfort for elevator passengers.

## References
1. **Fernández, J.R., Cortés, P., & Aparicio, P. (2010).** *Fuzzy Logic-Based Elevator Group Control System for Energy Optimization Purpose*. In **Proc. of CCCT 2010** (International Multi-Conference on Computer, Communication and Control Technologies).  ([CCCT 10 VF2](https://www.iiis.org/CDs2010/CD2010IMC/CCCT_2010/PapersPdf/TA970FQ.pdf#:~:text=passengers,raise%20buildings%20in%20general.%20In)) ([CCCT 10 VF2](https://www.iiis.org/CDs2010/CD2010IMC/CCCT_2010/PapersPdf/TA970FQ.pdf#:~:text=The%20more%20general%20problem%20assumes,cannot%20change%20the%20trip%20direction))

2. **Crites, R.H., & Barto, A.G. (1996).** *Improving Elevator Performance Using Reinforcement Learning*. In **Advances in Neural Information Processing Systems 8**, pp. 1017-1023.  ([Improving Elevator Performance Using Reinforcement Learning](http://papers.neurips.cc/paper/1073-improving-elevator-performance-using-reinforcement-learning.pdf#:~:text=This%20paper%20describes%20the%20application,a%20global%20reinforcement%20signal%20which)) ([Improving Elevator Performance Using Reinforcement Learning](http://papers.neurips.cc/paper/1073-improving-elevator-performance-using-reinforcement-learning.pdf#:~:text=other%20agents%2C%20the%20random%20nature,optimization%20problem%20of%20practical%20utility))

3. **Kaewta, C., & Sangkaphet, P. (2022).** *Differential Evolution Algorithm for Optimizing the Energy Usage of Vertical Transportation in an Elevator (VTE), Considering Rush Hour Management and COVID-19 Prevention*. **Sustainability, 14**(5), 2581.  ([Differential Evolution Algorithm for Optimizing the Energy Usage of Vertical Transportation in an Elevator (VTE), Taking into Consideration Rush Hour Management and COVID-19 Prevention](https://www.mdpi.com/2071-1050/14/5/2581#:~:text=problem%20of%20limited%20area,Therefore%2C%20making%20the%20energy)) ([Differential Evolution Algorithm for Optimizing the Energy Usage of Vertical Transportation in an Elevator (VTE), Taking into Consideration Rush Hour Management and COVID-19 Prevention](https://www.mdpi.com/2071-1050/14/5/2581#:~:text=Elevators%20in%20high,6%20%2C%20126%2C8))

4. **Ruokokoski, M., Ehtamo, H., & Pardalos, P.M. (2013).** *Elevator dispatching problem: a mixed integer linear programming formulation and polyhedral results*. **Journal of Combinatorial Optimization, 29**(4), 750-780.  ([Elevator dispatching problem: a mixed integer linear programming formulation and polyhedral results | CoLab](https://colab.ws/articles/10.1007%2Fs10878-013-9620-1#:~:text=In%20the%20static%20elevator%20dispatching,g))

5. **Lau, S.C., Jing, G.K., Rahman, A., & Ong, W.E. (2021).** *Solving the elevator dispatching problem using genetic algorithm*. **AIP Conference Proceedings, 2339**, 020020.  ([Solving the elevator dispatching problem using genetic algorithm | CoLab](https://colab.ws/articles/10.1063%2F5.0075278#:~:text=The%20elevator%20dispatching%20problem%20is,different%20procedures%20for%20Genetic%20Algorithm)) ([Solving the elevator dispatching problem using genetic algorithm | CoLab](https://colab.ws/articles/10.1063%2F5.0075278#:~:text=Genetic%20Algorithm%20,waiting%20time%20and%20computational%20time))

6. **Koehler, J., & Ottiger, D. (2002).** *An AI-based Approach to Destination Control in Elevators*. **AI Magazine, 23**(3), 59-78.  ([An AI-Based Approach to Destination Control in Elevators](https://ojs.aaai.org/aimagazine/index.php/aimagazine/article/download/1657/1555#:~:text=elevator%20control%20system%20selects%20an,5%20heading%20upward%20to%20serve)) ([An AI-Based Approach to Destination Control in Elevators](https://ojs.aaai.org/aimagazine/index.php/aimagazine/article/download/1657/1555#:~:text=passing%20floor%207,Using%20this%20information))

7. **Tartan, E.O., & Çiftlikli, C. (2016).** *A Genetic Algorithm Based Elevator Dispatching Method for Waiting Time Optimization*. **IFAC-PapersOnLine, 49**(3), 424-429.  ([[PDF] Genetic algorithm for controllers in elevator groups: analysis ...](https://www.semanticscholar.org/paper/Genetic-algorithm-for-controllers-in-elevator-and-Cort%C3%A9s-Larra%C3%B1eta/79629a63584ea53b989f3cb9153789f36c684d5d#:~:text=A%20Genetic%20Algorithm%20Based%20Elevator,Add%20to))

8. **Siikonen, M.-L. (1997).** *Planning and control models for elevators in high-rise buildings*. **Elevator World**, 45(5), 117-123.

9. **Sorsa, J. (2017).** *Optimization Models and Numerical Algorithms for an Elevator Group Control System*. Doctoral Dissertation, Aalto University.  ([Reducing Energy Consumption by an Optimization Algorithm](https://elevatorworld.com/article/reducing-energy-consumption-by-an-optimization-algorithm-in-elevator-group-control/#:~:text=Reducing%20Energy%20Consumption%20by%20an,Doctoral%20dissertation%2C%20Aalto%20University%2C%202017))

10. **Chan, W.L., & So, A.T.P. (1997).** *Dynamic zoning for elevator traffic control*. **IEEE Transactions on Industry Applications, 33**(1), 151-160. (Referenced in  ([An AI-Based Approach to Destination Control in Elevators](https://ojs.aaai.org/aimagazine/index.php/aimagazine/article/download/1657/1555#:~:text=located%20above%20car%20entrances,requested%20to%20indicate%20their%20destination)))

